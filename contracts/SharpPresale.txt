// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract SharpPresale is Ownable, ReentrancyGuard {
    IERC20 public sharpToken; // SHARP token contract
    uint256 public constant TOKENS_PER_BNB = 100_000 * 10 ** 18; // 100,000 SHARP per 1 BNB
    uint256 public constant MIN_CONTRIBUTION = 0.1 ether; // Minimum 0.1 BNB
    uint256 public constant MAX_CONTRIBUTION = 10 ether; // Maximum 10 BNB
    uint256 public constant PRESALE_CAP = 400_000_000 * 10 ** 18; // 400M SHARP for presale
    uint256 public tokensSold;

    bool public presaleActive = false;

    event TokensPurchased(address buyer, uint256 bnbAmount, uint256 tokenAmount);

    constructor(address tokenAddress) Ownable(msg.sender) {
        sharpToken = IERC20(tokenAddress);
    }

    // Start presale
    function startPresale() external onlyOwner {
        require(!presaleActive, "Presale already active");
        require(sharpToken.balanceOf(address(this)) >= PRESALE_CAP, "Insufficient token balance");
        presaleActive = true;
    }

    // Stop presale
    function stopPresale() external onlyOwner {
        require(presaleActive, "Presale not active");
        presaleActive = false;
    }

    // Buy tokens with BNB
    function buyTokens() external payable nonReentrant {
        require(presaleActive, "Presale not active");
        require(msg.value >= MIN_CONTRIBUTION, "Below minimum contribution");
        require(msg.value <= MAX_CONTRIBUTION, "Exceeds maximum contribution");

        uint256 tokenAmount = msg.value * TOKENS_PER_BNB / 1 ether;
        require(tokensSold + tokenAmount <= PRESALE_CAP, "Exceeds presale cap");

        tokensSold += tokenAmount;
        sharpToken.transfer(msg.sender, tokenAmount);

        emit TokensPurchased(msg.sender, msg.value, tokenAmount);
    }

    // Withdraw collected BNB
    function withdrawBNB() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No BNB to withdraw");
        payable(owner()).transfer(balance);
    }

    // Recover unsold tokens
    function recoverTokens() external onlyOwner {
        require(!presaleActive, "Presale still active");
        uint256 remainingTokens = sharpToken.balanceOf(address(this));
        if (remainingTokens > 0) {
            sharpToken.transfer(owner(), remainingTokens);
        }
    }
}